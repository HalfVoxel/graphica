#version 450
precision highp float;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (set=0, binding=0, rgba8) uniform restrict image2D image;
layout (set=0, binding=1, rgba32f) uniform restrict image2D temp_image;
layout (set=0, binding=2) uniform sampler s_brush;
layout (set=0, binding=3) uniform texture2D t_brush;

struct Primitive {
    uvec2 origin_src;
    uvec2 origin_dst;
};

layout(std140, binding = 4)
buffer restrict u_primitives { Primitive primitives[]; };

layout(std140, binding = 5)
uniform Settings {
    int width_per_group;
    int height_per_group;
    int num_primitives;
    int size_in_pixels;
};

layout(push_constant) uniform pushConstants {
    int work_index;
} u_pushConstants;

vec4 blend_over(vec4 a, vec4 b) {
    // A over B
    // TODO: Might need more numerically stable algorithm
    float alpha = a.a + b.a * (1 - a.a);
    vec3 rgb = (a.rgb * a.a + b.rgb * b.a * (1 - a.a)) / alpha;
    return vec4(rgb, alpha);
}

// A over B
// Assumes a and b are premultiplied by their alpha
vec4 blend_over_premultiplied(vec4 a, vec4 b) {
    // A over B
    return a + b * (1 - a.a);
}

void pass_a(int primitive_index) {
    uvec2 work = gl_GlobalInvocationID.xy;
    if (work.x > size_in_pixels || work.y > size_in_pixels) {
        return;
    }

    uvec2 origin_src = primitives[primitive_index].origin_src;
    origin_src += work;

    uvec2 origin_dst = primitives[primitive_index].origin_dst;
    origin_dst += work;

    for (int dy = 0; dy < height_per_group; dy++) {
        for (int dx = 0; dx < width_per_group; dx++) {
            uvec2 offset = uvec2(dx, dy) * gl_WorkGroupSize.xy;
            vec4 a = imageLoad(image, ivec2(origin_src + offset));
            vec4 b = imageLoad(image, ivec2(origin_dst + offset));
            vec2 uv = vec2(work + offset) / vec2(size_in_pixels, size_in_pixels);
            vec4 c = texture(sampler2D(t_brush, s_brush), uv);
            a.a *= c.a * 0.5;
            // a.a *= (float(work.y) / float(size_in_pixels)) * 0.5;
            // a.rgb *= a.a;
            // b.rgb *= b.a;
            vec4 result = blend_over(a, b);
            imageStore(temp_image, ivec2(work + offset), result);
        }
    }
}

void pass_b(int primitive_index) {
    uvec2 work = gl_GlobalInvocationID.xy;
    if (work.x > size_in_pixels || work.y > size_in_pixels) {
        return;
    }

    uvec2 origin_src = primitives[primitive_index].origin_src;
    origin_src += work;

    uvec2 origin_dst = primitives[primitive_index].origin_dst;
    origin_dst += work;

    for (int dy = 0; dy < height_per_group; dy++) {
        for (int dx = 0; dx < width_per_group; dx++) {
            uvec2 offset = uvec2(dx, dy) * gl_WorkGroupSize.xy;
            vec4 a = imageLoad(temp_image, ivec2(work + offset));
            imageStore(image, ivec2(origin_dst + offset), a);
        }
    }
}

void main() {
    int primitive = u_pushConstants.work_index / 2;
    if ((u_pushConstants.work_index % 2) == 0) {
        pass_a(primitive);
    } else {
        pass_b(primitive);
    }
}